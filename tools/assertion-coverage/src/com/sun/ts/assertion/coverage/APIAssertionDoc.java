/*
 * Copyright (c) 2002, 2018 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

/*
 * $URL$ $LastChangedDate$
 */

package com.sun.ts.assertion.coverage;

import org.jdom.*;
import org.jdom.output.*;
import com.sun.cts.api.data.*;
import java.io.*;
import java.util.*;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.Source;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.sax.SAXSource;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

public class APIAssertionDoc extends AssertionDoc implements HTMLDataProvider {

    /* Relative path to XSL file assuming ant invocation in the base directory */
    private static final String API_XSLT  = "../../docs/xsl/assertions/javadoc_assertions.xsl";

    private static final String OPTIONAL_OUT      = "optional.xml";
    private static final String TESTED_OUT        = "tested.xml";
    private static final String UNTESTED_OUT      = "untested.xml";
    private static final String DEPRECATED_OUT    = "deprecated.xml";
    private static final String REMOVED_OUT       = "removed.xml";
    private static final String UNTESTABLE_OUT    = "untestable.xml";
    private static final String HTML_SUMMARY_OUT  = "summary.html";
    private static final String HTML_TEST_IDS_OUT = "tests-to-ids.html";
    private static final String HTML_IDS_TEST_OUT = "ids-to-tests.html";

    /* Output files generated by this tool */
    private File optionalOut;
    private File testedOut;
    private File untestedOut;
    private File deprecatedOut;
    private File removedOut;
    private File untestableOut;
    private File summaryOutHTML;
    private File testToIDsHTML;
    private File idsToTestsHTML;
    private File coverageDir;

    /* Sorted and Tested assertion lists */
    private TestedAssertionList  testedAssertions;
    private JavadocAssertionList assertions;
    private JavadocAssertionList optional;
    private JavadocAssertionList deprecated;
    private JavadocAssertionList removed;
    private JavadocAssertionList untestable;
    private JavadocAssertionList tested;
    private JavadocAssertionList untested;

    /* Transformer for creating HTML output files */
    private Transformer          trans;

    /* Holds the names of the HTML files that need links in the summary page */
    private List htmlAssertionFilenames = new ArrayList();


    public APIAssertionDoc(Document assertionDoc,
			   Document testedAssertionDoc,
			   File coverageDir) {
	assertions       = new JavadocAssertionList(assertionDoc);
	testedAssertions = new TestedAssertionList(testedAssertionDoc);
	verifyTestedAssertionIDs(assertions, testedAssertions);
	this.coverageDir = coverageDir;
	createSortedAssertionLists();
	sortAssertions();
	setupOutputFiles();
	TransformerFactory factory = TransformerFactory.newInstance();
	Source xsltSource = new StreamSource(API_XSLT);
	try {
	    this.trans = factory.newTransformer(xsltSource);
	} catch (Exception e) {
	    System.err.println("Error, could not create a Transformer object, exiting ...");
	    System.exit(1);
	}
    }

    private void setupOutputFiles() {
	optionalOut     = new File(coverageDir, OPTIONAL_OUT);
	testedOut       = new File(coverageDir, TESTED_OUT);
	untestedOut     = new File(coverageDir, UNTESTED_OUT);
	deprecatedOut   = new File(coverageDir, DEPRECATED_OUT);
	removedOut      = new File(coverageDir, REMOVED_OUT);
	untestableOut   = new File(coverageDir, UNTESTABLE_OUT);
	summaryOutHTML  = new File(coverageDir, HTML_SUMMARY_OUT);
	idsToTestsHTML  = new File(coverageDir, HTML_IDS_TEST_OUT);
	testToIDsHTML   = new File(coverageDir, HTML_TEST_IDS_OUT);
    }


    /**
     * Creates a set of JavadocAssertionList instances.  The specified
     * assertions will be sorted and placed into these assertion lists.
     */
    private void createSortedAssertionLists() {
	try {
	    optional   = (JavadocAssertionList)(assertions.clone());
	    deprecated = (JavadocAssertionList)(assertions.clone());
	    removed    = (JavadocAssertionList)(assertions.clone());
	    untestable = (JavadocAssertionList)(assertions.clone());
	    tested     = (JavadocAssertionList)(assertions.clone());
	    untested   = (JavadocAssertionList)(assertions.clone());
	} catch (CloneNotSupportedException e) {
	    // this should never happen
	    System.err.println("$$$ Error cloning one of the 6" +
			       " sorting lists, Exiting ...");
	}
    }

    /**
     * Iterates over the assertions list and places each assertion in the
     * appropriate list.  There are 6 different lists; optional, deprecated,
     * removed, untestable, tested and untested.  Once the assertions are
     * sorted the client can instruct the APIAssertionDoc to write out each
     * file using the methods defined in the AssertionDoc interface.
     */
    private void sortAssertions() {
	JavadocAssertion[] assertionArray = assertions.getAssertions();
	for (int i = 0; i < assertionArray.length; i++) {
	    JavadocAssertion assertion = assertionArray[i];
	    if (!assertion.getRequired()) {
		optional.add(assertion);
	    } else if (assertion.getStatus().equalsIgnoreCase(JavadocAssertion.DEPRECATED)) {
		deprecated.add(assertion);
	    } else if (assertion.getStatus().equalsIgnoreCase(JavadocAssertion.REMOVED)) {
		removed.add(assertion);
	    } else if (!assertion.getTestable()) {
		untestable.add(assertion);
	    } else if (isTested(assertion.getID())) {
		tested.add(assertion);
	    } else if (!isTested(assertion.getID())) {
		untested.add(assertion);
	    } else {
		System.err.println("Error assertion does not fit into one "
				   + "of the six predefined catagories, "
				   + "assertion ID is \"" + assertion.getID()
				   + "\".");
	    }
	} // end for loop
    }
    
    private boolean isTested(String id) {
	boolean result = testedAssertions.contains(id) ||
	    testedAssertions.numsMatch(id);
	return result;
    }
    
    private void writeFile(File outFile, JavadocAssertionList list)
 	throws IOException
    {
 	XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
 	BufferedOutputStream fout =
	    new BufferedOutputStream(new FileOutputStream(outFile));
	Document doc = list.toXML();
	
 	try {
 	    out.output(doc, fout);
 	} finally {
 	    try { fout.close(); } catch (Exception e) {}
 	}
 	System.out.println(Globals.NL
 			   + "$$$ Assertion file generated \""
 			   + outFile + "\"");
    }
    
    private void transform(File inFile) {
	String inFileName  = inFile.getAbsolutePath();
	String outFileName = inFileName.replaceAll("xml?", "html");
	System.out.println("Transforming XML assertion file to HTML:");
	System.out.println("\t input file is  \"" + inFileName);
	System.out.println("\t output file is \"" + outFileName);
	File   outFile     = new File(outFileName);
    Result outSource   = new StreamResult(outFile);
	htmlAssertionFilenames.add(outFile);
	try {		
		Source inSource = null;
	    String localDTDPath = System.getProperty("local.dtd.path", "");
	    if (localDTDPath.length() > 0) {
	    	XMLReader reader = XMLReaderFactory.createXMLReader();
	    	reader.setEntityResolver(new MyResolver(localDTDPath));
	    	inSource = new SAXSource(reader, new InputSource(new FileReader(inFile)));
	    } else {
	    	inSource = new StreamSource(inFile);
	    }
	    trans.transform(inSource, outSource);
	} catch(Exception e) {
	    System.err.println("Error transforming the assertion file \"" + inFile + "\"");
	}
    }

    public void createOptionalFile() throws IOException {
	optional.sort();
	writeFile(optionalOut, optional);
	transform(optionalOut);
    }
    
    public void createTestedFile() throws IOException {
	tested.sort();
	writeFile(testedOut, tested);
	transform(testedOut);
    }

    public void createUntestedFile() throws IOException {
	untested.sort();
	writeFile(untestedOut, untested);
	transform(untestedOut);
    }
    
    public void createUntestableFile() throws IOException {
	untestable.sort();
	writeFile(untestableOut, untestable);
	transform(untestableOut);
    }
    
    public void createRemovedFile() throws IOException {
	removed.sort();
	writeFile(removedOut, removed);
	transform(removedOut);
    }

    public void createDeprecatedFile() throws IOException {
	deprecated.sort();
	writeFile(deprecatedOut, deprecated);
	transform(deprecatedOut);
    }

    public void createSummaryFile() throws IOException {
	System.out.println("$$$ Creating summary report page \"" +
			   summaryOutHTML + "\"");
	HTMLUtils.instance().createSummaryFile(summaryOutHTML, this);
    }
    
    public void createTestToIDFile() throws IOException {
	System.out.println("$$$ Creating test -> id mapping report \"" +
			   testToIDsHTML + "\"");
	HTMLUtils.instance().
	    createTestToIdMappingFile(testToIDsHTML, testedAssertions, this);
    }

    public void createIDToTestFile() throws IOException {
	System.out.println("$$$ Creating id -> test mapping report \"" +
			   idsToTestsHTML + "\"");
	HTMLUtils.instance().
	    createIDToTestMappingFile(idsToTestsHTML, testedAssertions, this);
    }


    /*** AssertionDoc Interface Implementation ***/

    public void createAssertionReports() throws IOException {
	createOptionalFile();
	createTestedFile();
	createUntestedFile();
	createUntestableFile();
	createRemovedFile();
	createDeprecatedFile();
	createTestToIDFile();
	createIDToTestFile();
	createSummaryFile();
    }

    /*** HTMLDataProvider Interface ***/

    public File[] getAssertionFileNames() {
	File[] result = new File[htmlAssertionFilenames.size()];
	return (File[])(htmlAssertionFilenames.toArray(result));
    }
    
    public File[] getTestIDMappingFileNames() {
	return new File[] {testToIDsHTML, idsToTestsHTML};
    }
    
    
    /* 
     * These methods differ for spec assertions only since API assertions
     * never have sub-assertions.  So just return the same value as the
     * getNumTested and getNumUntested methods.
     */
    public int getNumTestedNoParent()     { return tested.size();     }
    public int getNumUntestedNoParent()   { return untested.size();   }

    public int getNumTested()     { return tested.size();     }
    public int getNumUntested()   { return untested.size();   }
    public int getNumUntestable() { return untestable.size(); }
    public int getNumOptional()   { return optional.size();   }
    public int getNumDeprecated() { return deprecated.size(); }
    public int getNumRemoved()    { return removed.size();    }

    public String getTechnology()      { return assertions.getTechnology(); }
    public String getID()              { return assertions.getID();         }
    public String getName()            { return assertions.getName();       }
    public String getVersion()         { return assertions.getVersion();    }
    public boolean isSpec()            { return false;                      }

} // end class APIAssertionDoc
