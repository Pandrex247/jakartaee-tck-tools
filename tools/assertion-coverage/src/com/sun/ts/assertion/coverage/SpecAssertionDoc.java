/*
 * Copyright (c) 2002, 2018 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

/*
 * $URL$ $LastChangedDate$
 */

package com.sun.ts.assertion.coverage;

import org.jdom.*;
import org.jdom.output.*;
import com.sun.cts.spec.data.*;
import java.io.*;
import java.util.*;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.Source;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.sax.SAXSource;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

public class SpecAssertionDoc extends AssertionDoc implements HTMLDataProvider {

    /* Relative path to XSL file assuming ant invocation in the base directory */
    private static final String API_XSLT  = "../../docs/xsl/assertions/spec_assertions.xsl";

    private static final String OPTIONAL_OUT      = "optional.xml";
    private static final String TESTED_OUT        = "tested.xml";
    private static final String UNTESTED_OUT      = "untested.xml";
    private static final String DEPRECATED_OUT    = "deprecated.xml";
    private static final String REMOVED_OUT       = "removed.xml";
    private static final String UNTESTABLE_OUT    = "untestable.xml";
    private static final String HTML_SUMMARY_OUT  = "summary.html";
    private static final String HTML_TEST_IDS_OUT = "tests-to-ids.html";
    private static final String HTML_IDS_TEST_OUT = "ids-to-tests.html";

    /* Output files generated by this tool */
    private File optionalOut;
    private File testedOut;
    private File untestedOut;
    private File deprecatedOut;
    private File removedOut;
    private File untestableOut;
    private File summaryOutHTML;
    private File testToIDsHTML;
    private File idsToTestsHTML;
    private File coverageDir;

    /* Sorted and Tested assertion lists */
    private TestedAssertionList  testedAssertions;
    private SpecAssertions assertions;
    private SpecAssertions optional;
    private SpecAssertions deprecated;
    private SpecAssertions removed;
    private SpecAssertions untestable;
    private SpecAssertions tested;
    private SpecAssertions untested;

    /* Transformer for creating HTML output files */
    private Transformer          trans;

    /* Holds the names of the HTML files that need links in the summary page */
    private List htmlAssertionFilenames = new ArrayList();


    public SpecAssertionDoc(Document assertionDoc,
			    Document testedAssertionDoc,
			    File coverageDir) {
	assertions       = new SpecAssertions(assertionDoc);
	testedAssertions = new TestedAssertionList(testedAssertionDoc);
	verifyTestedAssertionIDs(assertions, testedAssertions);
	this.coverageDir = coverageDir;
	createSortedAssertionLists();
	sortAssertions(assertions.getAssertions());
	
	checkForSatisfiedParentAssertions();
	testedNoParents   = countNonParents(tested);
	untestedNoParents = countNonParents(untested);

	clearSubAssertions();
	setupOutputFiles();
	TransformerFactory factory = TransformerFactory.newInstance();
	Source xsltSource = new StreamSource(API_XSLT);
	try {
	    this.trans = factory.newTransformer(xsltSource);
	} catch (Exception e) {
	    System.err.println("Error, could not create a Transformer object, exiting ...");
	    System.exit(1);
	}
    }

    /* 
     * Added to set the state of a parent assertion to tested if all it's
     * sub-assertions are tested.
     */
    private void checkForSatisfiedParentAssertions() {
 	int numTested = tested.size();
 	int numUntested = untested.size();
//  	System.out.println
//  	    ("$$$ Before: Num Tested = " + numTested + ", Num Untested = " + numUntested);
	SpecAssertion[] untestedAssertions = untested.getAssertions();
	for (int i = 0; i < untestedAssertions.length; i++) {
	    SpecAssertion currentAssertion = untestedAssertions[i];
//  	    System.out.println
//  		("\t$$$ Checking assertion ID: " + currentAssertion.getID());
	    if (currentAssertion.isTested()) {
//  		System.out.println("\t\t$$$ All sub-assertions are tested");
// 		System.out.println("\t\t$$$ Adding tested assertion ID " +
// 				   currentAssertion.getID());
		tested.add(currentAssertion);
		untested.remove(currentAssertion);
	    } else {
//  		System.out.println("\t\t$$$ Not all sub-assertions are tested");
	    }
	}
	numTested = tested.size();
 	numUntested = untested.size();
//  	System.out.println
//  	    ("$$$ After: Num Tested = " + numTested + ", Num Untested = " + numUntested);
    }

    private void setupOutputFiles() {
	optionalOut     = new File(coverageDir, OPTIONAL_OUT);
	testedOut       = new File(coverageDir, TESTED_OUT);
	untestedOut     = new File(coverageDir, UNTESTED_OUT);
	deprecatedOut   = new File(coverageDir, DEPRECATED_OUT);
	removedOut      = new File(coverageDir, REMOVED_OUT);
	untestableOut   = new File(coverageDir, UNTESTABLE_OUT);
	summaryOutHTML  = new File(coverageDir, HTML_SUMMARY_OUT);
	idsToTestsHTML  = new File(coverageDir, HTML_IDS_TEST_OUT);
	testToIDsHTML   = new File(coverageDir, HTML_TEST_IDS_OUT);
    }


    /**
     * Creates a set of SpecAssertions list instances.  The specified
     * assertions will be sorted and placed into these assertion lists.
     */
    private void createSortedAssertionLists() {
	try {
	    optional   = (SpecAssertions)(assertions.clone());
	    deprecated = (SpecAssertions)(assertions.clone());
	    removed    = (SpecAssertions)(assertions.clone());
	    untestable = (SpecAssertions)(assertions.clone());
	    tested     = (SpecAssertions)(assertions.clone());
	    untested   = (SpecAssertions)(assertions.clone());
	} catch (CloneNotSupportedException e) {
	    // this should never happen
	    System.err.println("$$$ Error cloning one of the 6" +
			       " sorting lists, Exiting ...");
	}
    }

    /**
     * Iterates over the assertions list and places each assertion in the
     * appropriate list.  There are 6 different lists; optional, deprecated,
     * removed, untestable, tested and untested.  Once the assertions are
     * sorted the client can instruct the APIAssertionDoc to write out each
     * file using the methods defined in the AssertionDoc interface.
     */
    private void sortAssertions(SpecAssertion[] assertionArray) {
	for (int i = 0; i < assertionArray.length; i++) {
	    SpecAssertion assertion = assertionArray[i];
	    if (!assertion.getRequired()) {
		optional.add(assertion);
	    } else if (assertion.getStatus() == SpecAssertion.DEPRECATED) {
		deprecated.add(assertion);
	    } else if (assertion.getStatus() == SpecAssertion.REMOVED) {
		removed.add(assertion);
	    } else if (!assertion.getTestable()) {
		untestable.add(assertion);
	    } else if (isTested(assertion)) {
		tested.add(assertion);
	    } else if (!isTested(assertion)) {
		untested.add(assertion);
	    } else {
		System.err.println("Error assertion does not fit into one "
				   + "of the six predefined catagories, "
				   + "assertion ID is \"" + assertion.getID()
				   + "\".");
	    }
	    if (assertion.hasSubAssertions()) {
		sortAssertions(assertion.getAssertions());
	    }
	} // end for loop
    }
    
    /*
     * Does this assertion ID appear in the tested list or does any of its
     * ancestor's assertion IDs appear in the tested list.  If so we return
     * true and mark all assertions in the recursed heirarchy as being tested.
     */
    private boolean isTested(SpecAssertion assertion) {
	boolean result = false;
	String id = assertion.getID();
	result = testedAssertions.contains(id) ||
	    testedAssertions.numsMatch(id);
	if (!result) {
	    if (assertion.getParent() != null) {
		result = isTested(assertion.getParent());
	    }
	}
	if (result) {
	    assertion.setTested();
	}
	return result;
    }
    
    private void writeFile(File outFile, SpecAssertions list)
 	throws IOException
    {
 	XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
 	BufferedOutputStream fout =
	    new BufferedOutputStream(new FileOutputStream(outFile));
	Document doc = list.toXMLDocument();
	
 	try {
 	    out.output(doc, fout);
 	} finally {
 	    try { fout.close(); } catch (Exception e) {}
 	}
 	System.out.println(Globals.NL
 			   + "$$$ Assertion file generated \""
 			   + outFile + "\"");
    }
    
    private void transform(File inFile) {
	String inFileName  = inFile.getAbsolutePath();
	String outFileName = inFileName.replaceAll("xml?", "html");
	System.out.println("Transforming XML assertion file to HTML:");
	System.out.println("\t input file is  \"" + inFileName);
	System.out.println("\t output file is \"" + outFileName);
	File   outFile     = new File(outFileName);
    Result outSource   = new StreamResult(outFile);
	htmlAssertionFilenames.add(outFile);
	try {
		Source inSource = null;
	    String localDTDPath = System.getProperty("local.dtd.path", "");
	    if (localDTDPath.length() > 0) {
	    	XMLReader reader = XMLReaderFactory.createXMLReader();
	    	reader.setEntityResolver(new MyResolver(localDTDPath));
	    	inSource = new SAXSource(reader, new InputSource(new FileReader(inFile)));
	    } else {
	    	inSource = new StreamSource(inFile);
	    }
	    trans.transform(inSource, outSource);
	} catch(Exception e) {
	    System.err.println("Error transforming the assertion file \"" + inFile + "\"");
	}
    }

    public void createOptionalFile() throws IOException {
	optional.sort();
	writeFile(optionalOut, optional);
	transform(optionalOut);
    }
    
    public void createTestedFile() throws IOException {
	tested.sort();
	writeFile(testedOut, tested);
	transform(testedOut);
    }

    public void createUntestedFile() throws IOException {
	untested.sort();
	writeFile(untestedOut, untested);
	transform(untestedOut);
    }
    
    public void createUntestableFile() throws IOException {
	untestable.sort();
	writeFile(untestableOut, untestable);
	transform(untestableOut);
    }

    public void createRemovedFile() throws IOException {
	removed.sort();
	writeFile(removedOut, removed);
	transform(removedOut);
    }

    public void createDeprecatedFile() throws IOException {
	deprecated.sort();
	writeFile(deprecatedOut, deprecated);
	transform(deprecatedOut);
    }

    public void createSummaryFile() throws IOException {
	System.out.println("$$$ Creating summary report page \"" +
			   summaryOutHTML + "\"");
	HTMLUtils.instance().createSummaryFile(summaryOutHTML, this);
    }
    
    public void createTestToIDFile() throws IOException {
	System.out.println("$$$ Creating test -> id mapping report \"" +
			   testToIDsHTML + "\"");
	HTMLUtils.instance().
	    createTestToIdMappingFile(testToIDsHTML, testedAssertions, this);
    }

    public void createIDToTestFile() throws IOException {
	System.out.println("$$$ Creating id -> test mapping report \"" +
			   idsToTestsHTML + "\"");
	HTMLUtils.instance().
	    createIDToTestMappingFile(idsToTestsHTML, testedAssertions, this);
    }

    private void clearSubAssertionsFromList(SpecAssertions list) {
	SpecAssertion[] assertions = list.getAssertions();
	for (int i = 0; i < assertions.length; i++) {
	    assertions[i].clearSubAssertions();
	}
    }

    private void clearSubAssertions() {
	clearSubAssertionsFromList(optional);
	clearSubAssertionsFromList(deprecated);
	clearSubAssertionsFromList(removed);
	clearSubAssertionsFromList(untestable);
	clearSubAssertionsFromList(tested);
	clearSubAssertionsFromList(untested);
    }


    /*** AssertionDoc Interface Implementation ***/

    public void createAssertionReports() throws IOException {
	createOptionalFile();
	createTestedFile();
	createUntestedFile();
	createUntestableFile();
	createRemovedFile();
	createDeprecatedFile();
	createTestToIDFile();
	createIDToTestFile();
	createSummaryFile();
    }

    /*** HTMLDataProvider Interface ***/

    public File[] getAssertionFileNames() {
	File[] result = new File[htmlAssertionFilenames.size()];
	return (File[])(htmlAssertionFilenames.toArray(result));
    }
    
    public File[] getTestIDMappingFileNames() {
	return new File[] {testToIDsHTML, idsToTestsHTML};
    }
    
    private int countNonParents(SpecAssertions list) {
	int result = 0;
	SpecAssertion[] assertions = list.getAssertions();
	for (int i = 0; i < assertions.length; i++) {
	    if (!assertions[i].hasSubAssertions()) {
		result += 1;
	    }
	}
	return result;
    }

    private int testedNoParents;
    private int untestedNoParents;
    public  int getNumTestedNoParent() { return testedNoParents; }
    public  int getNumUntestedNoParent() { return untestedNoParents; }
    public  int getNumTested()     { return tested.size();     }
    public  int getNumUntested()   { return untested.size();   }
    public  int getNumUntestable() { return untestable.size(); }
    public  int getNumOptional()   { return optional.size();   }
    public  int getNumDeprecated() { return deprecated.size(); }
    public  int getNumRemoved()    { return removed.size();    }

    public String getTechnology()      { return assertions.getTechnology(); }
    public String getID()              { return assertions.getID();         }
    public String getName()            { return assertions.getName();       }
    public String getVersion()         { return assertions.getVersion();    }
    public boolean isSpec()            { return true;                       }

} // end class SpecAssertionDoc
